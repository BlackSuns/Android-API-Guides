# 概述 #

+ 一个Activity表示应用程序中一个屏幕的用户界面；
+ Activities可以移至后台并和被保存的状态一起恢复；


# 目录 #

创建Activity
> 实现用户界面    
> 在清单文件中声明Activity    

启动Activity
> 启动接收返回结果的Activity  

关闭Activity

管理Activity的声明周期
> 实现生命周期回调函数    
> 保存Activity的状态    
> 处理配置变化    
> Actiivites间的协作  

# Activities #

Activity是用来提供与用户交互的应用程序组件，比如打电话、拍照、发邮件或者查看地图。每个Activity都提供了用于绘制用户界面的窗口。这个窗口通常是覆盖整个屏幕的，但也可能比屏幕小并且悬浮在其他窗口之上。

应用程序通常由多个Activity组成，且有一个首次进入应用程序呈现给用户的“main” Actiivty。Activity可以启动其他Activity来完成不同的动作。每次新的Activity启动之后，上一个Activity就会停止，但系统会将这个Activity保留在栈中（the “Back Stack”）。新启动的Activity会被压入回退栈的栈顶并获得用户焦点。回退栈是基于“后进先出”的机制，因此，当用户按下返回按钮时，栈顶的Activity会被弹出栈（即销毁），前一个Activity就会恢复。

由于新的Activity启动，前一个Activity就会停止，它们的状态变化是通过Activity的生命周期回调方法通知的。Activity根据状态的变化可能会接收到几种不同的回调方法，你可以利用这些回调方法执行相应的工作。比如，Activity停止时需要释放类似与网络或者数据库连接这些大对象。Activity恢复时需要获取所需的资源和被中断的操作。这些状态的转换就是Activity的生命周期。

文档剩下的内容将会介绍怎样去创建和使用Activity，包括Activity的生命周期是怎么运行的，这样一来，你就可以正确地管理Activity的状态转换。


## 创建Activity ##

首先，你需要创建一个Activity的子类。在该子类中，你需要实现Activity状态转换时被系统调用的回调方法，其中，两个最重要的回调方法是：

onCreate()
> 必须实现该方法。系统在创建Activity时会调用。在你的实现中，你需要初始化Activity的主要组件。更重要的是，你必须调用setContentView()方法来定义Activity的用户界面。

onPause()
> 系统调用该方法作为用户离开Activity（通常不是指Activity被销毁）的第一个迹象。这里通常是提交在当前用户会话中需要保存的数据的地方（因为用户可能不会回到这个Activity）。

为了在多个Activity间提供流畅的用户体验和处理未知操作导致Activity停止和销毁，你还需要实现几个其他的生命周期回调方法。所有的生命周期回调方法都会在之后的*管理Activity的生命周期*小节中讨论。


### 实现用户界面 ###

Activity的用户界面是由层级结构的视图提供的-View的衍生对象。视图控制着Activity窗口的一块特定矩形区域并能够响应用户的交互。比如，视图是一个用户点击时会产生动作的按钮。

Android提供了很多现成的视图，你可以使用这些视图来设计和组织布局。“部件”是提供屏幕可视元素的视图，比如按钮，文本域，多选框或者图片。“布局”是提供唯一的布局模型，由ViewGroup衍生的对象，比如线性布局、网格布局或者相对布局。你可以继承View和ViewGroup来自定义部件和布局。

定义布局最常用的方式是使用保存在应用程序资源目录下的XML布局文件编写。这种方式使得用户界面的设计与定义Activity行为的代码分离。你可以使用setContentView(布局的资源ID)方法来设置Activity的用户界面。然而，你也可以在代码中创建视图，并将视图添加到布局中，然后使用setContentView(ViewGroup)方法设置用户界面。

关于创建用户界面的更多内容，可以查看[用户界面](http://developer.android.com/guide/topics/ui/index.html)文档。


### 在清单文件中定义Activity ###

你必须在清单文件中声明Activity以便系统可以访问它。你可以打开清单文件， 在&lt;application&gt;节点中添加一个&lt;activity&gt;的子节点。例如：

```
<manifest ... >
  <application ... >
      <activity android:name=".ExampleActivity" />
      ...
  </application ... >
  ...
</manifest >
```

你可以在&lt;activity&gt;节点中添加一些属性来定义Activity的特性，比如标签，图标或者UI的样式主题。*android:name*是唯一必须的属性-指定Activity的类名。一旦发布应用程序，你不要修改这个名称，因为这样会影响某些功能，比如应用程序快捷方式（看这篇博客[不能改变的东西](http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html)）。


### 使用意图过滤器 ###

&lt;activity&gt;节点可以指定不同的意图过滤器-使用&lt;intent-filter&gt;-用来声明其它应用程序组件怎样启动它。

当你使用Android SDK工具创建新的应用程序时，创建的Activity自动包含了声明该Activity响应"main"动作和放置在“启动器”目录的意图过滤器。如下：


```
<activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

&lt;action&gt;节点指明了这是应用程序的主要入口。&lt;category&gt;节点指明了这个Activity会出现在系统的应用程序启动器中。

如果你的应用程序不允许其它应用程序启动组件，你不需要声明任何意图过滤器。有且只有一个Activity有“main”动作和“启动器”目录的意图过滤器。不对其它应用程序开放的Activity不需要意图过滤器，你可以使用显式意图去启动它们。

然而，如果你需要Activity响应隐式意图，你必须声明额外的意图过滤器。需要响应的每种类型的意图都必须在&lt;action&gt;节点中添加响应的&lt;intent-filter&gt;。

有关Activity如何响应意图的更多内容，请查看[意图和意图过滤器](http://developer.android.com/guide/components/intents-filters.html)文档。


## 启动Activity ##

你可以通过调用接收意图参数的startActivity()方法启动Activity。这个意图指明了需要启动的Activity或者描述了需要执行的动作类型。意图还可以携带少量被启动Activity需要用到的数据。

在你自己的应用程序中，你常常需要启动一个已知的Activity。你可以创建一个指明了需要启动的Activity的意图。比如：

```java
Intent intent = new Intent(this, SignInActivity.class);
startActivity(intent);
```

然而，你的应用程序可能也需要使用你的Activity的数据去执行一些动作，比如发送邮件、短信或者状态更新。这种情况下，你的应用程序可能没有相应的Activity来完成这样的动作，因此你可以利用由系统中其他应用程序提供的Activity来完成。这才是意图真正有价值的地方-创建一个描述了需要执行的动作，系统会启动合适的Activity。如果有多个Activity可以处理你请求的动作，用户可以选择其中之一。比如：

```java
Intent intent = new Intent(Intent.ACTION_SEND);
intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);
startActivity(intent);
```

添加到意图中的*EXTRA_EMAIL*额外数据是需要发送邮件的邮箱地址。当邮箱应用程序响应该意图时，它会读取提供的邮箱地址并放入写邮件的“发送到”域中。


### 启动返回结果的Activity ###

你可能有时候需要从你启动的Activity中接收结果。在这种情况下，可以通过startActivityForResult()来启动一个Activity。然后在Activity中实现onActivityResult()方法来接收随后启动的Activity返回的结果。例如：

```java
private void pickContact() {
    // Create an intent to "pick" a contact, as defined by the content provider URI
    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
    startActivityForResult(intent, PICK_CONTACT_REQUEST);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST
    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {
        // Perform a query to the contact's content provider for the contact's name
        Cursor cursor = getContentResolver().query(data.getData(),
        new String[] {Contacts.DISPLAY_NAME}, null, null, null);
        if (cursor.moveToFirst()) { // True if the cursor is not empty
            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);
            String name = cursor.getString(columnIndex);
            // Do something with the selected contact's name...
        }
    }
}
```

这个例子展示了使用onActivityResult()方法处理结构的基本逻辑。第一个条件检查请求是否成功-如果成功，resultCode是RESULT_OK-并且响应结果的请求是否已知-requestCode与startActivityForResult()方法的第二个参数匹配。之后就是处理Activity传回来的结果了。


## 关闭Activity ##

你可以调用finish()方法来关闭Activity。也可以调用finishActivity()方法来关闭之前启动的Activity。

> **注意：**大部分情况下，你都不需要显式关闭Actiivty。接下来的小节将讨论到Activity的生命周期，Android系统会帮你管理Activity的生命周期，因此你不需要关闭Activity。调用这些关闭方法可能会应用用户体验，并且只有在你确实不再需要的时候才关闭它们。


## 管理Activity的生命周期 ##

通过实现回调方法来管理Activity的生命周期对于开发健壮灵活的应用程序至关重要。Activity的生命周期被与之关联的其它Activity，任务和回退栈直接影响。

Activity主要有三种状态：
*恢复*
> Activity在前台并获得用户焦点（这个状态也通常叫做“正在运行”状态）

*暂停*
> 其它Activity在前台并获得焦点，但该Activity还可见。也就是说，其它Activity部分透明或者没有完全覆盖整个屏幕。暂停状态下的Activity完全是存活的（Actiivty对象在内存中保留，它管理所有的状态和成员信息，并附属在窗口管理器），但在系统内存严重不足的情况下会被销毁。

*停止*
> Activity完全被其它Activity覆盖了。停止状态下的Activity也仍然是存活的（Activity对象在内存中保留，它管理所有状态和成员信息，但没有附属在窗口管理器）。然而，它不再对用户可见，因此在系统需要回收内存时可以被销毁。

如果Activity处于暂停或停止状态，系统可以通过调用finish()方法或者直接杀掉进程来回收内存。当Activity出现打开时，它完全是重新创建的。


### 实现生命周期回调方法 ###

当Activity在上面提到的状态之间转换时，它会触发不同的回调方法。所有回调方法都是钩子，你可以重写它们去做合适的工作。如下：

```java
public class ExampleActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // The activity is being created.
    }
    @Override
    protected void onStart() {
        super.onStart();
        // The activity is about to become visible.
    }
    @Override
    protected void onResume() {
        super.onResume();
        // The activity has become visible (it is now "resumed").
    }
    @Override
    protected void onPause() {
        super.onPause();
        // Another activity is taking focus (this activity is about to be "paused").
    }
    @Override
    protected void onStop() {
        super.onStop();
        // The activity is no longer visible (it is now "stopped")
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        // The activity is about to be destroyed.
    }
}
```
> ***注意：*如上面的例子一样，在所有生命周期回调方法的实现中都必须先调用父类的方法

这些回调方法定义了Activity的整个生命周期。通过实现这些方法，你可以意识到在Actiivty的生命周期中有三个嵌套循环：

+ Activity的**整个生命周期**发生在onCreate()和onDestory()之间。Activity需要在onCreate()中执行全局状态的设定，比如定义布局，在onDestroy()中释放所有保留的资源。比如，如果Activity在后台有运行的线程从网络上下载数据，那么在onCreate()中创建该线程并在onDestory()中中断它。

+ Activity的**可视生命周期**发生在onStart()和onStop()之间。在此之间，用户可以与之交互。比如，onStop()在新Activity启动并且该Activity不再可见时调用。在这两个方法之间，你可以管理展示给用户的资源。比如，你可以在onStart()中注册一个广播接收器去监测影响UI的变化，在onStop()时注销。

+ Activity的**前台生命周期**发生在onResume()和onPause()之间。在此期间，Actiivty在所有其它Activity之前并获得用户输入焦点。Activity会频繁地在前台之间来回切换-比如，onPause()在设备休眠或者对话框出现时被调用。因为这个状态经常切换，所以为了避免用户等待，这两个方法的代码必须是轻量的。

以下这张图展示了这些嵌套循环和状态之间的切换路径。
![Alt "生命周期"](../images/activity_lifecycle.png)


# 原文地址 #

<http://developer.android.com/guide/components/activities.html>
